# Copyright (c) 2025 sakib-maho
# Licensed under the MIT License
# See LICENSE file for details

# -*- coding: utf-8 -*-
"""A-star.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M8BZK9ygI5AIv6ab5jlHdi_lxjpf2Pc3
"""

import queue 
maps={
    "0":'S', 
    "1":'A',
    "2": 'B',
    "3": 'C',
    "4": 'D',
}
#Adjacent list with weight. the cost of going s to a = 1, ato b = 4 and so on.
adjacent_lists = ['A 1','B 4'],['B 2','C 5','D 12'],['C 2'],['D 3'],['none']
#List for keeping the h values of each node. 0th index keeps the h value of 0th node.
heuristic_lists = [7,6,2,1,0]
sample = ['S','A','B','C','D']

class Node:
  def __init__(self, node_no, previous_n_object, actual_travel_cost, total_cost):
    self.node_no = node_no
    self.previous_n_object = previous_n_object
    self.actual_travel_cost = actual_travel_cost
    self.total_cost = total_cost

#Min priority queue minQ. here, put to add in queue AND get to remove item from queue
minQ = []

flag = Node(0, "none", 0, 7)
minQ.append((flag.total_cost, flag))

destination = 'D'
actual_cost  = 0

while minQ:
  try:
    minQ.sort(reverse=True)
    x=minQ.pop()
  except:
    x=minQ.pop()   
  temp = str(x[1].node_no)
  #Final result
  if destination == maps[temp]:
    print(f"Cost : {x[1].actual_travel_cost}")
    print("Solutation Path :", end=' ')
    #Recursively solution path printing from path()
    def path(x):
      if x == "none":
        return
      path(x[1].previous_n_object) #Sending previous address
      print(maps[str(x[1].node_no)], end=" ")
    path(x)
    break
  #End of if
  for i in adjacent_lists[x[1].node_no]:
    temp = i.split(" ")
    adjacent = temp[0]
    cost = temp[1]
    index = sample.index(adjacent)
    actual_cost = int(x[1].actual_travel_cost) + int(cost)
    total_cost_so_far = actual_cost + heuristic_lists[index]
    new_object = Node(index, x, actual_cost, total_cost_so_far)
    minQ.append((int(total_cost_so_far), new_object))